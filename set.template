#include <iostream>
#include <algorithm>

namespace main_savitch_10
{
template<class Item>
set<Item>::set( )
{
  data_count = 0;
  child_count = 0;
}

template<class Item>
set<Item>::set(const set& source)
{
  data_count = source.data_count;
  child_count = source.child_count;
  for(int i = 0; i < data_count; i++)
  {
    data[i] = source.data[i];
  }
  for(int i = 0; i < child_count; i++)
  {
    subset[i] = new set<Item>(*(source.subset[i]));
  }
}

template<class Item>
void set<Item>::operator =(const set& source)
{
  clear();
  data_count = source.data_count;
  child_count = source.child_count;
  for(int i = 0; i < data_count; i++)
  {
    data[i] = source.data[i];
  }
  for(int i = 0; i < child_count; i++)
  {
    subset[i] = new set<Item>(*(source.subset[i]));
  }
}

template<class Item>
void set<Item>::clear( )
{
  //delete set recursively
  data_count = 0;
  for(int i = 0; i < child_count; i++)
  {
    subset[i]->clear();
  }
  for(int i = 0; i < child_count; i++)
  {
    delete subset[i];
  }
  //set private member variables to default values
  child_count = 0;
}

template<class Item>
bool set<Item>::insert(const Item& entry)
{
  if(!loose_insert(entry))
  {
    return false;
  }
  if(data_count > MAXIMUM)
  {
    Item leftData[MINIMUM];
    Item rightData[MINIMUM];
    Item middle = data[MINIMUM];
    for(int j = 0; j < MINIMUM; j++)
    {
      leftData[j] = data[j];
      rightData[j] = data[MINIMUM + 1 + j];
    }
    set<Item> * newLeft = new set<Item>;
    set<Item> * newRight = new set<Item>;
    for(int i = 0; i < MINIMUM; i++)
    {
      newLeft->data[i] = leftData[i];
      newLeft->data_count++;
      newRight->data[i] = rightData[i];
      newRight->data_count++;
    }
    if(child_count != 0)
    {
    for(int i = 0; i < MINIMUM + 1; i++)
    {
      newLeft->subset[i] = subset[i];
      newLeft->child_count++;
      newRight->subset[i] = subset[MINIMUM + 1 + i];
      newRight->child_count++;
    }
    }
    data[0] = middle;
    subset[0] = newLeft;
    subset[1] = newRight;
    child_count = 2;
    data_count = 1;
  }
  return true;
}

template<class Item>
std::size_t set<Item>::erase(const Item& target)
{
  if(!loose_erase(target))
  {
    return false;
  }
  if((data_count == 0) && (child_count == 1))
  {
    set<Item>* temp = subset[0];
    data_count = 0;
    for(int i = 0; i < temp->data_count; i++)
    {
      data[data_count++] = temp->data[i];
    }
    child_count = 0;
    for(int i = 0; i < temp->child_count; i++)
    {
      subset[child_count++] = temp->subset[i];
    }
    temp->child_count = 0;
    temp->data_count = 0;
    delete temp;
  }
  return true;
}

template<class Item>
std::size_t set<Item>::count(const Item& target) const
{
  if(data_count == 0) return 0;
  for(int i = 0; i < data_count; i++)
  {
    if(target == data[i]) return 1;
    else if(target < data[i] && child_count > i) return subset[i]->count(target);
  }
  if(target > data[data_count - 1] && child_count > data_count) return subset[data_count]->count(target);
  return 0;
}

template<class Item>
void set<Item>::print(int indent) const
{
  const int EXTRA_INDENTATION = 4;
  std::size_t i;

  std::cout << std::setw(indent) << "";

  for(int i = 0; i < data_count; i++)
  {
    std::cout << data[i] << " ";
  }
  std::cout << std::endl;
  for(int i = 0; i < child_count; i++)
  {
    subset[i]->print(indent + EXTRA_INDENTATION);
  }
}

template<class Item>
bool set<Item>::loose_insert(const Item& entry)
{
  if(child_count == 0 && data_count < MAXIMUM + 1)
  {
    data[data_count] = entry;
    std::sort(data, data + data_count);
    data_count++;
    return true;
  }
  for(int i = 0; i < data_count; i++)
  {
    if(entry == data[i]) return false;
    if(entry < data[i])
    {
      bool var = subset[i]->loose_insert(entry);
      if(subset[i]->data_count == MAXIMUM + 1)
      {
        fix_excess(i);
      }
      return var;
    }
  }
  if(entry > data[data_count - 1])
  {
    bool var = subset[child_count- 1]->loose_insert(entry);
    if(subset[child_count - 1]->data_count == MAXIMUM + 1)
    {
      fix_excess(child_count - 1);
    }
    return var;
  }
  return false;
}

template<class Item>
bool set<Item>::loose_erase(const Item& target)
{
  for(int i = 0; i < data_count; i++)
  {
    if(target == data[i] && child_count == 0)
    {
      data[i] = data[data_count - 1];
      data_count--;
      std::sort(data, data + data_count);
      return true;
    }
    else if(target == data[i] && child_count > 0)
    {
      // internal node deletion
      subset[i]->remove_biggest(data[i]);

      if(subset[i]->data_count < MINIMUM)
      {
        fix_shortage(i);
      }
      return true;
    }
    else if(target < data[i] && child_count > i)
    {
      bool var = subset[i]->loose_erase(target);
      if(subset[i]->data_count < MINIMUM)
      {
        fix_shortage(i);
      }
      return var;
    }
  }
  if(target > data[data_count - 1] && child_count > data_count)
  {
    bool var = subset[data_count]->loose_erase(target);
    if(subset[data_count]->data_count < MINIMUM)
    {
      fix_shortage(data_count);
    }
    return var;
  }
  return false;
}

template<class Item>
void set<Item>::remove_biggest(Item& removed_entry)
{
  if(child_count == 0)
  {
    removed_entry = data[data_count-- - 1];
  }
  else
  {
    subset[child_count-1]->remove_biggest(removed_entry);
    if(subset[child_count-1]->data_count < MINIMUM) fix_shortage(child_count - 1);
  }
}

template<class Item>
void set<Item>::fix_excess(std::size_t i)
{
  Item leftData[MINIMUM];
  Item rightData[MINIMUM];
  Item middle = subset[i]->data[MINIMUM];
  for(int j = 0; j < MINIMUM; j++)
  {
    leftData[j] = subset[i]->data[j];
    rightData[j] = subset[i]->data[MINIMUM + 1 + j];
  }
  delete subset[i];
  subset[i] = new set<Item>;
  for(int j = 0; j < MINIMUM; j++)
  {
    subset[i]->data[j] = leftData[j];
    subset[i]->data_count++;
  }
  subset[i + 1] = new set<Item>;
  child_count++;
  for(int j = 0; j < MINIMUM; j++)
  {
    subset[i+1]->data[j] = rightData[j];
    subset[i+1]->data_count++;
  }
  data[data_count++] = middle;
}

template<class Item>
void set<Item>::fix_shortage(std::size_t i)
{
    if(i + 1 < child_count && subset[i+1]->data_count > MINIMUM) // right sibling has more than MINIMUM keys, then take 1 key and 1 child from right sibling
    {
      Item keyFromSibling, keyFromParent;
      set<Item>* childFromSibling;
      // get key and child from right sibling and then adjust right sibling's arrays
      keyFromSibling = subset[i+1]->data[0];
      keyFromParent = data[i];
      childFromSibling = subset[i+1]->subset[0];
      for(int j = 0; j < subset[i+1]->data_count - 1; j++)
      {
        subset[i+1]->data[j] = subset[i+1]->data[j + 1];
      }
      subset[i+1]->data_count--;
      for(int j = 0; j + 1< subset[i+1]->child_count; j++)
      {
        subset[i+1]->subset[j] = subset[i+1]->subset[j + 1];
      }
      if(subset[i+1]->child_count > 0) subset[i+1]->child_count--;
      // move the key from the right sibling to the parent node
      data[i] = keyFromSibling;
      // move the new key and child to subset i
      subset[i]->data[subset[i]->data_count++] = keyFromParent;
      if(subset[i]->child_count != 0) subset[i]->subset[subset[i]->child_count++] = childFromSibling;
    }
    else if(i != 0 && subset[i-1]->data_count > MINIMUM) // if left sibling has more than MINIMUM keys, then take 1 key and 1 child from left sibling
    {
      Item keyFromSibling, keyFromParent;
      set<Item>* childFromSibling;
      // get key and child from left sibling and then adjust left sibling's arrays
      keyFromSibling = subset[i-1]->data[subset[i-1]->data_count-- - 1];
      keyFromParent = data[i-1];
      if(subset[i-1]->child_count != 0) childFromSibling = subset[i-1]->subset[subset[i-1]->child_count-- - 1];

      // move the key from the left sibling to the parent node
      data[i-1] = keyFromSibling;

      // move the new key and child to subset i
      for(int j = subset[i]->data_count; j > 0; j--)
      {
        subset[i]->data[j] = subset[i]->data[j - 1];
      }
      subset[i]->data_count++;
      subset[i]->data[0] = keyFromParent;
      for(int j = subset[i]->child_count; j > 0; j--)
      {
        subset[i]->subset[j] = subset[i]->subset[j - 1];
      }
      if(subset[i]->child_count != 0)
      {
        subset[i]->child_count++;
        subset[i]->subset[0] = childFromSibling;
      }
    }
    else if(i > 0 && subset[i-1]->data_count == MINIMUM) //combine with left sibling
    {
      subset[i-1]->data[subset[i-1]->data_count++] = data[i-1];
      for(int j = i-1; j < data_count - 1; j++)
      {
        data[j] = data[j+1];
      }
      data_count--;
      for(int j = 0; j < subset[i]->data_count; j++)
      {
        subset[i-1]->data[subset[i-1]->data_count++] = subset[i]->data[j];
      }
      for(int j = 0; j < subset[i]->child_count; j++)
      {
        subset[i-1]->subset[subset[i-1]->child_count++] = subset[i]->subset[j];
      }
      subset[i]->child_count = 0;
      subset[i]->data_count = 0;
      //delete subset[i];
      for(int j = i; j < child_count - 1; j++)
      {
        subset[j] = subset[j + 1];
      }
      if(child_count != 0)
      {
        child_count--;
      }
    }
    else if(i == 0 && subset[i+1]->data_count == MINIMUM) // combine with right sibling
    {
      subset[i]->data[subset[i]->data_count++] = data[i];
      for(int j = i; j < data_count - 1; j++)
      {
        data[j] = data[j+1];
      }
      data_count--;
      for(int j = 0; j < subset[i+1]->data_count; j++)
      {
        subset[i]->data[subset[i]->data_count++] = subset[i+1]->data[j];
      }
      for(int j = 0; j < subset[i+1]->child_count; j++)
      {
        if(subset[i]->child_count != 0)
        {
          subset[i]->subset[subset[i]->child_count++] = subset[i+1]->subset[j];
        }
      }
      subset[i + 1]->child_count = 0;
      subset[i+1]->data_count = 0;
      delete subset[i + 1];
      for(int j = i + 1; j < child_count - 1; j++)
      {
        subset[j] = subset[j + 1];
      }
      if(child_count != 0)
      {
        child_count--;
      }
    }
  }
}
